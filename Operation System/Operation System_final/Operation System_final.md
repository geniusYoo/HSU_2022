# OS STUDY_FINAL

강의 번호: OS

- chap08 : 메모리 관리
    - RAM vs HDD
        - RAM : 반도체 기억 장치, 메모리, 전원이 끊어지면 저장된 정보가 사라짐
        - HDD : 보조 기억 장치, 전원이 끊어져도 정보가 사라지지 않음
        - 하드디스크가 없는 컴퓨터는 존재할 수 있어도, 메인 메모리가 없는 컴퓨터는 존재할 수 없다.
        
    - 메모리 계층 구조
        - 메모리는 CPU가 실행할 프로그램 코드와 데이터를 저장하는 물리 장치
        - 컴퓨터 시스템의 모든 기억 공간들을 포괄적으로 메모리라고 하면, 메모리는 컴퓨터 시스템 내에 여러 곳에 배치되어 사용된다.
        - 메모리 계층화
            - CPU 레지스터 - CPU 캐시 - **메인 메모리** - 보조기억장치
            - 갈 수록 용량 증가, 가격 저렴, 속도 저하
            - 메모리 계충 구조의 중심은 **메인 메모리**
        - 메모리 계층화의 역사적 과정
            - CPU 성능 향상 → 더 빠른 메모리 요구 → 작지만 빠른 off-chip 캐시 → 더 빠른 액세스를 위해 on-chip 캐시→ 멀티코어에 적합한 L1,L2,L3 캐시
            - 메모리 계층화는 성능과 비용의 절충, 빠른 메모리일수록 고가여서 적은 용량을 사용
        - 메모리 계층화의 목적
            - CPU의 메모리 액세스 시간을 단축시키기 위해, 빠른 프로그램 실행을 위해
        - 메모리 계층구조의 각 요소
            - CPU 레지스터 : CPU는 현재 실행할 코드와 데이터, 혹은 다음에 실행할 몇개의 코드와 데이터를 미리 저장할 목적으로 레지스터를 가지고 있다. CPU에는 일반적으로 8~30개 정도의 레지스터가 있다. Intel Core i7은 16개, RISC 스타일의 ARM8의 경우 30개의 레지스터가 있다.
            - 캐시 메모리 : 메인 메모리보다 더 빠른  메모리, CPU가 캐시 메모리에서 프로그램 코드와 데이터를 읽어 실행함
            - 메인 메모리 : 현재 실행중인 모든 프로세스의 코드와 데이터, 읽거나 쓰고 있는 여러 파일들의 블록 뿐만 아니라 운영체제의 커널 코드와 커널 데이터들이 저장됨. 캐시메모리에는 메인 메모리부터 당장 실행에 필요한 일부분의 코드와 데이터가 복사되는데, 사용자 프로그램과 운영체제 커널을 구분하지 않고 복사된다.
            - 보조 기억 장치 : HDD, SSD와 같이 전원을 꺼도 지워지지 않는 대용량 저장 장치, 파일이나 데이터베이스 등을 저장할 목적으로 사용되지만, 스왑 영역으로도 사용됨
            
            |  | CPU 레지스터  | L1, L2 캐시 | L3 캐시 | 메인 메모리 | 보조 기억 장치 |
            | --- | --- | --- | --- | --- | --- |
            | 용도 | 몇 개의 명령, 데이터 저장 | 한 코어에서 실행되는 명령, 데이터 저장 | 멀티 코어들에 의해 공유. 명령, 데이터 저장 | 실행중인 전체 프로세스들의 코드, 데이터와 입출력 중인 파일 블록들 저장 | 프로세스의 코드와 데이터의 일시 저장 |
            | 용량 | 바이트 단위, 1KB 미만 | KB 단위 (i7 기준 32KB/256KB) | MB 단위 (i7 기준 8MB) | GB 단위 (최근 PC는 8GB이상) | TB 단위 |
            | 타입 |  | SRAM  | SRAM | DRAM | 마그네틱 필드나 플래시 메모리 |
            | 속도 | <1ns | <5ns | <5ns | <50ns | <20ms |
            | 가격 |  | 고가 | 고가 | 보통 | 저가 |
            | 휘발성 | O | O | O | O | X |
        - DRAM(Dynamic) vs SRAM(Static)
            
            
            | DRAM | SRAM |
            | --- | --- |
            | F/F, refresh 계속 필요 | 수백개의 F/F → 비용 증가 |
            | refresh logic 필요 | 필요 X |
            | 만들기 쉽고 집약도 높음 | 안정적임 |
            | 속도가 느림 | 속도 매우 빠름 |
            | Main Memory | Secondary Memory, Cache Memory |
        - 메모리 계층에서 코드, 데이터의 이동
            
            ![스크린샷 2022-06-01 22.05.14.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-01_22.05.14.png)
            
            - CPU는 메모리에서 명령을 처리 X, L1, L2 캐시에서 명령, 데이터를 가져와서 실행
            - 만약 실행할 코드 데이터가 L1,L2 캐시에 없으면 → L3에서 채움, 캐시 미스, 그 동안 CPU 대기
            - L3에도 없으면 RAM → L3 → L1/L2로 연쇄적으로 이동
    - 참조의 지역성
        - 코드나 데이터, 자원 등이 아주 짧은 시간 내에 다시 사용되는 프로그램의 일반적인 특성
        - CPU는 작은 캐시 메모리에 적재된 코드와 데이터로 한동안 실행
        - 캐시를 챙누는 시간의 손해보다 빠른 캐시를 이용하는 이득이 큼
    - 메모리 관리
        - 관리 이유
            - 메모리는 공유 자원
            - 메모리는 보호되어야 함
            - 메모리 용량 한계 극복 필요
            - 메모리 효율성 증대를 위해
        - 어떤 운영체제든 반드시 지원되어야 하는 메모리 관리 기능 2가지
            - 메모리 할당
            - 메모리 보호
    
    - 메모리 주소
        - 물리 주소와 논리 주소
            - 물리 주소 : 컴퓨터를 설계하고 제작하는 시점에 물리메모리에 매겨지는 하드웨어적인 주소, 0번지부터 시작, CPU 패키지가 발생시키는 주소
            - 논리 주소 : 프로세스 내에서 코드나 데이터의 주소, 가상주소와 동일, CPU가 발생시키는 주소
            - **MMU에 의한 주소 변환 (중요 **)**
            
            ![스크린샷 2022-06-01 22.31.01.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-01_22.31.01.png)
            
        - 이들은 모두 논리 주소
            - CPU가 인지하는 모든 주소
            - 동적할당 받은 메모리의 주소
            - 함수 호출시에 사용되는 스택 주소
        - **CPU도 현재 실행하는 명령이 물리 메모리 몇 번지에 있는지 알지 못함, 오직 MMU만이 알고 있다.**
        - 논리 주소는 항상 같지만, 물리 주소는 계속 바뀜 → 메모리 어디에 할당할 지 모르니까 ,,
        - ASLR, Address Space Layout Randomization
            - 해커들의 메모리 공격을 어렵게 하기 위해 도입
            - 프로세스 주소 공간 내에서 스택,라이브러리,힙의 영역을 랜덤으로 배치해 실행할 때마다 논리 주소가 바뀌게 하는 기법
            - 코드나 데이터 영역의 위치는 안바뀜, 스택이나 힙 영역만 바뀜 !
        
    - 물리 메모리 관리
        - 메모리 할당
            - 운영체제가 새 프로세스를 실행시키거나 실행중인 프로세스가 메모리를 필요로 할 때 물리 메모리를 할당하는 것
            - 프로세스의 실행은 물리 메모리에서 이루어진다.
            - 고정 크기 할당 IBM OS/360 MFT
                
                ![스크린샷 2022-06-03 14.02.36.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-03_14.02.36.png)
                
            - 가변 크기 할당 IBM OS/360 MVT
                
                ![스크린샷 2022-06-03 14.04.04.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-03_14.04.04.png)
                
        - 연속 메모리 할당 (contiguous memory allocation)
            - 각 프로세스에게 메모리 한 덩어리씩 할당하는 기법
            - 여기서 연속이란, 프로세스가 할당받은 메모리가 한 덩어리로 연속된 공간이라는 뜻.
            - 초기의 메모리 할당 기법
            - 고정 크기 할당 (fixed size partition allocation)
                - 메모리 전체를 파티션이라는 고정 크기로 나누고 프로세스마다 1개의 파티션을 할당
                - 적재할 수 있는 프로세스 개수 n개가 정해짐, 그래서 n개의 프로세스가 실행되고 있을 때 새로운 프로세스가 도착하면 프로세스 하나가 종료될 때까지 작업 큐에서 대기
                - 프로세스가 파티션의 크기보다 작은 경우, 낭비되는 공간 많음
                - 프로세스가 파티션의 크기보다 큰 경우, 처음부터 실행될 수 없는 문제 발생
            - 가변 크기 할당 (variable size partition allocation)
                - 프로세스마다 프로세스 크기의 메모리를 할당
                - 파티션도 가변 크기
            
            ![스크린샷 2022-06-01 22.53.45.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-01_22.53.45.png)
            
        
        - 분할 메모리 할당 (non-contiguous memory allocation)
            - 연속 메모리 할당의 유연성을 해결하기 위해 도입
            - 프로세스에게 필요한 메모리를 여러 덩어리로 나누어 분산 할당하는 기법
            - 각 프로세스에게 프로세스와 동일한 크기의 메모리를 할당
            - 가변 크기 할당 - 세그먼테이션 (segmentation)
                - 프로세스를 여러개의 논리적인 덩어리로 분할하고 각 덩어리를 세그먼트라고 부른다.
                - 세그먼트 : 프로세스 내에서 하나의 단위로 다룰 수 있는 의미있는 블록
                - 프로세스를 구성하는 세그먼트들을 동일한 크기로 물리 메모리에 분산 할당
            - 고정 크기 할당 - 페이징 (paging)
                - 프로세스를 논리주소 0번지부터 페이지라는 고정 크기로 분할
                - 물리 메모리 역시 페이지와 같은 크기로 분할해 프레임이라고 부름
                - 프로세스의 각 페이지를 물리 메모리의 프레임에 하나씩 분산 할당
            
            ![스크린샷 2022-06-01 22.54.16.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-01_22.54.16.png)
            
        
        - 단편화
            - 프로세스에게 할당할 수 없는 작은 크기의 조각 메모리들 (홀, hole)이 생기는 현상
            - 메모리 할당 요청에 사용할 수 없게 된 작은 홀이 생기는 현상
            - 내부 단편화
                - 프로세스에게 할당된 메모리 영역 내에 활용할 수 없는 홀이 생기는 경우
                - 고정 크기 할당 시 파티션 내에 내부 단편화 발생
                    
                    ![스크린샷 2022-06-03 14.16.46.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-03_14.16.46.png)
                    
            - 외부 단편화
                - 할당된 메모리들 사이에 활용할 수 없는 홀이 생기는 경우
                - 가변 크기 할당 시 파티션과 파티션 사이에 외부 단편화 발생
                    
                    ![스크린샷 2022-06-03 14.17.12.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-03_14.17.12.png)
                    
        
        - 연속 메모리 할당 구현
            - 장점 : 논리주소 → 물리주소 과정 단순, CPU의 메모리 액세스 속도 빠름, 운영체제가 관리할 정보량, 부담 감소
            - 단점 : 메모리 할당 유연성 감소
            - 하드웨어 지원
                - base 레지스터 : 현재 실행 중인 프로세스에게 할당된 물리 메모리 시작 주소
                - limit 레지스터 : 현재 실행 중인 프로세스에게 할당된 메모리 크기
                - 주소 레지스터 : 현재 액세스하는 메모리의 논리 주소
                - 주소 변환 하드웨어 (MMU) : 논리 주소를 물리 주소로 변환
            - 운영체제 지원
                - 프로세스의 물리 메머리의 시작 주소와 크기 정보를 CPU 내부의 base 레지스터와 limit 레지스터에 적재시켜야 한다
        - 홀 선택 알고리즘 & 동적 메모리 할당
            - 운영체제는 프로세스를 실행하는 도중이나 처음 실행할 때 적당한 홀을 선택해서 할당해야 하는데 이를 말함
            - 가변 크기 할당 알고리즘
                - first-fit : 홀 리스트를 검색하여 처음으로 만나는, 요청 크기보다 큰 홀을 선택 → 속도 빠르지만 외부 단편화로 인한 메모리 낭비가 큼
                - best-fit : 홀 리스트를 검색하여 요청 크기를 수용하는 것 중 가장 작은 홀을 선택 → 결과적으로 할당된 홀 영역 내에 가장 작은 홀이 생김 → 홀 리스트를 전부 검색하는 부담
                - worst-fit : 홀 리스트를 검색하여 요청 크기를 수용하는 것 중 가장 큰 홀을 선택 → 결과적으로 할당된 홀 내에 가장 큰 홀이 생김 → 홀 리스트를 전부 검색하는 부담
        - 연속 메모리 할당의 장단점
            - 장점 : 알고리즘이 단순해 구현이 용이, 논리 주소를 물리 주소로 바꾸는 과정이 단순해 CPU가 메모리를 액세스 하는 속도가 빠름, 운영체제의 부담이 덜함
            - 단점 : 프로세스에게 하나의 연속된 메모리를 할당하므로 메모리 할당의 유연성이 부족, 작은 홀들을 합하면 충분한 공간이 있어도 프로세스에게 메모리 공간을 할당할 수 없는 경우가 발생, 메모리 압축 과정 필요
            
    - 세그먼테이션 메모리 관리
        - 세그먼트 : 세그먼테이션에서 프로세스를 구성하는 논리 블록, 프로그램을 구성하는 논리적 단위
        - 세그먼테이션 : 각 논리 세그먼트에 한 덩어리의 물리 메모리를 할당하는 기법
        - 세그먼테이션 기법을 사용하려면 컴파일러, 링커, 로더의 도움이 있어야 함
            - 컴파일러와 링커 : 응용프로그램, 라이브러리의 코드를 한 군데로 모아 코드 세그먼트를 구성 + 전역 변수, 정적 변수들을 모아 데이터 세그먼트를 구성 → 실행 파일 생성
            - 로더 : 프로그램이 실행될 때 실행 파일 내에 구성되어 있는 각 논리 세그먼트에 대해 물리 메모리에서 동일한 크기로 물리 세그먼트를 할당하고 논리 세그먼트를 물리 세그먼트에 적재
            - 운영체제 : 프로세스 실행 시 필요한 크기의 스택 세그먼트와 힙 세그먼트를 물리 메모리에 할당
        - 세그먼트 테이블
            - 시스템 전체에 1개 → why? 프로세스 당 세그먼트의 개수가 작기 때문에
            - 항목 : base(세그먼트의 시작 물리 주소) + limit(세그먼트의 크기)
            - 현재 실행 중인 모든 프로세스에 대해 논리 세그먼트 당 하나의 항목이 저장됨
        
        ![스크린샷 2022-06-07 11.07.58.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_11.07.58.png)
        
        - 세그먼테이션의 구현
            - CPU, 컴파일러, 링커, 운영체제, 로더 등이 모두 세그먼테이션을 지원해야 함
            - 세그먼트에 대한 정의, 구현은 CPU에 매우 의존적이고 운영체제마다 다르게 구현될 수 있음
            - 하드웨어 지원
                - 논리 주소 구성
                    - 프로그램 코드, 데이터의 주소는 세그먼트 내에서의 상대 주소(offset)으로 컴파일, 세그먼트에는 번호가 매겨짐
                    - 세그먼테이션 논리 주소 = [ 세그먼트 번호 , offset ]
                    - 변수 n이 데이터 세그먼트 내 100번지에 있도록 컴파일, 데이터 세그먼트가 2번 세그먼트에 할당된다면 변수 n 값을 읽어오는 기계 명령
                        
                        `move ds, 2`
                        
                        `move ax, [ds : 100 ]  // 2번 세그먼트 내 옵셋 100번지를 읽어 ax에 저장`
                        
                - CPU
                    - 세그먼트 테이블은 메모리에 저장되므로 CPU에는 세그먼트 테이블의 시작 주소를 가리키는 레지스터(segment table base register)가 필요하다
                - MMU
                    - MMU에는 메모리 보호(논리 주소가 세그먼트 크기를 넘어서는지 판별), 주소 변환(논리 주소를 물리 주소로 변환)의 두 기능이 구현됨
                - 세그먼트 테이블
                    - 세그먼트 테이블을 메모리에 두면 CPU가 논리 주소를 발생시켜 메모리를 액세스할 때마다 현재 세그먼트의 limit, base 값을 알아내려고 메모리에 있는 세그먼트 테이블을 액세스 해야해서 실행 속도에 부담 → 세그먼트 테이블 일부를 MMU에 두기도 함
                    - 프로세스들의 논리 세그먼트 - 물리 세그먼트 매핑
                    
                    ![스크린샷 2022-06-07 11.34.04.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_11.34.04.png)
                    
                    1. CPU에서 논리주소 발생 
                    2. 메모리에 저장된 세그먼트 테이블에서 세그먼트 번호에 해당하는 항목 읽혀짐
                    3. 항목의 limit, offset을 비교해 limit<offset → 시스템 오류 
                    4. limit>offset → 세그먼트 테이블의 항목에 들어있는 물리 세그먼트의 시작 주소(base)와 offset을 더해 물리 주소 출력
                    
        - 세그먼테이션은 프로세스에게 가변 크기로 물리 세그먼트들을 할당하므로 외부 단편화가 필연적으로 발생하고 내부 단편화는 없다.
- chap11 : 파일 시스템 관리
    1. 파일 시스템과 저장 장치
        
        1.1 파일과 저장 장치
        
        - 파일이란 ?
            - 사용자나 응용 프로그램에게는 정보를 저장하고 관리하는 논리적인 단위
            - 컴퓨터 시스템에게는 0과 1의 데이터 덩어리
        - 파일의 생성, 기록, 읽혀짐의 모든 과정은 운영체제에 의해서만 통제
        
        1.2 디스크 장치 개요
        
        - 하드 디스크는 자성체로 코팅된 여러개의 원판(플래터, platter)에 디지털 정보를 저장하고 읽어내는 장치
            
            ![스크린샷 2022-06-07 11.48.14.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_11.48.14.png)
            
        - 디스크 대체 모듈
            - 플래터 (platter) : 정보가 기록되는 저장소, 모두 스핀들에 연결되어 함꼐 회전
            - 디스크 헤드 : 플래터 표면과 일정 간격을 유지한 채 플래터에서 정보를 읽거나 기록
            - 플래터에는 아래, 위 모두 정보가 저장됨 → 플래터 당 2개의 디스크 헤드가 존재
            - 모든 암(arm)들은 하나의 구동기(actuator)에 달려있어 함께 안팎으로 움직임
        - 디스크 제어 모듈
            - 프로세서 : 호스트로부터 명령을 받고 해석하는 하드웨어 처리기, 디스크 매체 모듈 제어, 물리적인 디스크 액세스 진행
            - 디스크 캐시 : 1MB~몇십MB 크기의 빠른 반도체 메모리, 호스크와 디스크 매체 모듈 사이의 전송되는 디스크 블록들이 임시 저장되는 중간 버퍼 역할
        - 트랙 : 플래터에 정보가 저장되는 하나의 동심원, 여러개의 섹터를 포함
        - 섹터 : 플래터에 정보가 저장되는 최소 단위, 512바이트 또는 4096바이트
        - 실린더 : 같은 반지름을 가진 모든 트랙 집합
        - 블록 : 운영체제가 파일 데이터를 입출력하는 논리적인 단위
        
        1.3 파일 입출력 주소
        
        - 디스크 물리 주소와 논리 블록 주소
            - 응용프로그램 : 파일 내 바이트 주소 사용
                - 바이트 번호 (offset)을 사용해 입출력을 함
            - 운영체제 : 논리 블록 주소 사용
                - LBA (Logical Block Address) = 디스크의 모든 블록들을 일차원 배열로 나열하고 번호를 매긴 주소
            - 디스크 장치 : 디스크 물리 주소 사용
                - CHS (Cylinder-Head-Sector) 물리주소 = [실린더 번호, 헤드 번호, 섹터 번호]
        - 파일 주소 변환
            
            ![스크린샷 2022-06-07 12.05.03.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_12.05.03.png)
            
            - 응용프로그램에서 파일 내 바이트 주소의 변환
                
                `파일 내 바이트 주소 → 논리 블록 주소 → CHS 물리 주소`
                
        - 주소 계층화 의미
            - 각 계층의 독립적 구현 용이
                - 사용자나 응용프로그램, 운영체제, 디스크 장치는 각각 독립적으로 정의된 기능 수행
            - 응용 프로그램 개발
                - 파일을 바이트 단위로 입출력하는 코드 작성
                - 운영체제의 종류나 특징에 관계없이 파일 입출력 응용프로그램 개발
                - 저장매체의 종류나 특징, 저장 위치에 무관하게 작성 가능
            - 운영체제 개발
                - 저장매체를 1차원 배열의 논리 블록들로 다루어 논리 블록 번호를 이용해 디스크 입출력 시행 → 저장매체 종류나 하드웨어 특징에 관계없이 운영체제 구현 가능
                - 운영체제는 바이트 주소를 논리 블록 주소로 바꿈 → 응용프로그램을 장치로부터 독립
            - 저장 장치 (디스크 장치) 개발
                - 논리 블록 번호를 CHS 물리 주소로 바꾸어 디스크 입출력 → 응용프로그램이나 운영체제의 특성과 무관하게 저장 장치 개발
        
        1.4 파일 시스템의 정의와 범위
        
        <aside>
        💡 파일 시스템은 저장 매체에 파일을 생성하고 저장하고 읽고 쓰는 운영체제의 기능을 통칭하는 말이다.
        
        </aside>
        
        - 파일 시스템의 범위, 파일 시스템을 구성하는 4가지 요소
            - 파일 시스템의 논리 구조 : 여러 파일을 다루기 위한 계층 구조
            - 저장 장치에 파일 시스템 구축 : 파일들을 저장 매체 속에 블록 단위로 분산 저장하고 관리하기 위한 체계
            - 커널 내 파일 입출력 구현 : 파일 생성, 열기, 읽기, 쓰기, 닫기, 삭제, 메타정보 읽기/변경
            - 응용프로그램을 위한 파일 시스템 인터페이스
            
            ![스크린샷 2022-06-07 13.07.23.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_13.07.23.png)
            
        
        1.5  파일 시스템 입출력 계층
        
        ![스크린샷 2022-06-07 13.09.54.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_13.09.54.png)
        
        - 응용프로그램은 일반적으로 파일 입출력 라이브러리를 이용해 작성됨
        - 라이브러리는 필요에 따라 시스템 호출을 이용해 운영체제에게 파일 입출력을 요청
        - 파일 입출력 계층에서 정상이라고 판단되면 요청된 파일 데이터의 바이트 주소를 논리 블록 주소(LBA)로 바꿈
        - 논리 블록 입출력 계층에서는 논리 블록 주소에 해당하는 디스크 블록이 커널 내의 버퍼 캐시에 있는지 확인하고 있으면 버퍼 캐시에서 읽고 씀, 없으면 디스크 장치 드라이버를 통해 디스크 장치로 논리 블록 주소를 보내 입출력 지시
        - 물리 저장소 입출력 계층은 저장 장치에서 구현되는 계층으로 논리 블록 주소를 저장 장치의 물리 주소로 바꾸어 데이터를 액세스함
        
        1.6 파일 읽기 사례
        
        ![스크린샷 2022-06-07 15.30.53.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_15.30.53.png)
        
        - 파일 읽기 과정을 통한 주목 사항
            - 파일 읽기에서 각 계층의 역할이 잘 구분됨
            - 운영체제는 응용프로그램이 저장장치의 종류, 구조, 위치 등 물리적인 특성에 무관하게 입출력 지원
            - 디스크 디바이스 드라이버가 파일에 대한 논리적 공간과 물리적 공간 분리
            - 파일 데이터는 여러번의 복사를 거쳐 이동
                - 디스크 플래터 → 디스크 캐시 → 커널의 버퍼 캐시 → 라이브러리의 버퍼 → 응용프로그램 버퍼
                - 여러번의 복사로 인해 많은 시간 소요, 하지만 동일한 파일이 여러번 액세스되거나 여러 응용 프로그램들이 동일한 파일을 액세스하는 경우, 한 프로그램이 순차적으로 파일 데이터를 읽는 경우 효과적
            
    2. 파일 시스템의 논리 구조
        
        2.1 파일 시스템 구조
        
        - 대부분 트리 계층 구조의 파일 시스템 구성
        - 디렉터리
            - 논리적인 관점 : 여러 파일 또는 서브 디렉터리를 포함하는 컨테이너, 파일에 대한 경로 제공
            - 물리적인 관점 : 디렉터리도 파일로 구현되고 이루어짐, 디렉터리는 파일이나 서브 디렉터리의 이름, 위치정보, 속성 등을 저장하는 특별한 파일
            
            <aside>
            💡 디렉터리는 서브 디렉터리나 파일들의 이름 목록을 저장한 **파일**이다.
            
            </aside>
            
            - 루트 디렉터리 : 파일 시스템 계층 구조의 최상위 디렉터리
            - 서브 디렉터리 : 루트 디렉터리의 하부에 존재하는 디렉터리
        - 파일 이름과 경로명
            - 단순 파일 이름
            - 파일 경로명 : 루트 디렉터리에서부터 계층 구조를 포함하는 완전한 파일 이름
        
        2.2 파일 시스템 메타 정보와 파일 메타 정보
        
        - 운영체제는 파일 시스템을 다루기 위해 2개의 메타 정보를 만들고 활용함
        - 파일 시스템 메타 정보
            - 파일 시스템 전체에 대한 정보
            - 파일 시스템 전체 크기와 현재 사용 크기
            - 저장 장치에 구축된 파일 시스템의 비어 있는 크기
            - 저장 장치의 빈 블록들 리스트 등 ..
            - 저장되는 위치는 운영체제마다 다르고 운영체제가 쉽게 읽고 쓸 수 있도록 저장 매체의 특별한 위치에 저장
        - 파일 메타 정보
            - 파일에 관한 여러 정보로서 파일 데이터는 포함되지 않음
            - 파일 이름, 크기, 만들어진 시간, 수정된 시간, 속성, 저장된 위치 등 ..
            - 저장되는 위치는 파일 시스템마다 다르고 디렉터리 내 또는 저장 매체의 특별한 위치(예 : i-node)에 저장
            - Linux_파일 메타 정보 중 파일 속성
                
                ![스크린샷 2022-06-07 15.56.47.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_15.56.47.png)
                
    3. 파일 시스템 구축
        
        3.1 파일 시스템 구현 이슈
        
        - 디스크 장치에 비어있는 블록들의 리스트를 어떻게 관리할 것인가 ?
        - 파일 블록들을 디스크의 어느 영역에 분산 배치할 것인가 ?
        - 파일 블록들이 저장된 디스크 내 위치들을 어떻게 관리할 것인가 ?
        
        3.2 FAT 파일 시스템
        
        - 1980년대 개인용 PC를 관리하는 MS-DOS 운영체제의 파일 시스템
        - 구조
            
            ![스크린샷 2022-06-07 16.03.04.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_16.03.04.png)
            
            - 부트 섹터(디스크의 맨 첫번째 섹터)에서 루트 디렉터리까지의 공간은 FAT 파일 시스템을 구축할 때 고정 크기로 설정됨
        - 부트 섹터
            - 한 섹터 크기로 파일 시스템 메타 정보 및 디스크에 관련된 정보들과 컴퓨터가 부팅할 때 실행되는 코드가 저장되는 영역
            - 부트 섹터에 저장된 정보들
                - DOS 버전, 섹터 당 바이트 수, 블록 당 섹터 수, FAT 개수, 루트 디렉터리 항목 개수, 전체 섹터 수, FAT당 섹터 수, 트랙 당 섹터 수, 디스크 헤드 개수 등
                - 이 정보들을 이용하면 파일 시스템 전체 크기를 알 수 있고, FAT 테이블 항목들을 조사하면 현재 파일 시스템 내에서 사용중인 블록들, 비어있는 블록들을 알 수 있다.
            - MS-DOS의 운영체제 커널 코드는 IO.SYS, MSDOS.SYS 파일에 들어있고, 이들은 루트 디렉터리에 hidden, read-only, system 속성으로 저장되어 있음
        - FAT1, FAT2
            - FAT, File Allocation Table (파일 할당 테이블) : 파일 시스템의 전체 파일에 대해 파일이 저장된 디스크 블록들의 번호가 저장되는 곳
        - 루트 디렉터리
            - FAT2 바로 뒤에 구성 → why? 파일 찾을 때 루트 디렉터리 찾기 쉽도록 위치 고정
            - 크기도 고정 → why? 파일 블록들이 저장된 위치를 찾기 쉽게 하려고
            - 루트디렉터리 크기 고정 → 생성되는 파일이나 서브 디렉터리 개수도 고정
        - 데이터 블록들
            - 루트 디렉터리를 제외한 모든 파일의 데이터 블록들이 저장되는 영역
            - 각 파일을 블록 단위로 데이터 블록 영역 내에 분산 저장됨
        - 디렉터리
            - 파일의 목록을 담은 특별한 파일
            - 루트 디렉터리나 서브 디렉터리 모두 구조는 동일
            - FAT 파일 시스템 - 이름 최대 8글자, 확장자 최대 3글자 → 8.3형식
            - FAT 파일 시스템에서 디렉터리 항목은 하나의 파일 메타 정보를 모두 저장, 이 때 가장 중요한 건 시작 블록 번호(파일이 저장된 첫번째 디스크 블록 번호)
        - 파일 블록 배치
            - FAT 파일 시스템은 파일 데이터를 블록 단위로 디스크에 분산 저장하고 저장된 위치는 FAT에 기록됨, 이 항목들은 연결리스트로 연결
            - 파일 메타 데이터는 디렉터리에 저장
            - 파일이 저장된 모든 블록 알아내기
                - 파일이 포함된 디렉터리 항목 검색
                - 디렉터리 항목에는 해당 파일이 시작되는 FAT 항목 번호, 해당 파일 크기가 저장
                - 디렉터리 항목을 이용해 FAT 테이블을 연결리스트 방식으로 검색해 파일이 저장된 블록들을 알아냄
                
                ![스크린샷 2022-06-07 16.16.11.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_16.16.11.png)
                
            - 하나의 파일을 읽는 데 여러번 디스크 탐색이 필요 → 파일이 여러개 블록으로 나뉘어 분산 저장 되므로
            - FAT에서 항목 번호는 2번부터 사용됨
                - -1 : 파일의 마지막 블록
                - 0 : 사용 가능한 자유 블록
                - 2 ~ : 파일의 다음 블록 번호
                - FAT의 항목은 부팅 시에 모두 0으로 초기화 → 모든 블록이 사용가능함을 나타냄
            - FAT 테이블의 항목 크기가 16비트라면, 접근 가능한 총 블록 수는 총 2^16개
            - 만약 디스크 블록 크기가 4KB 이라면 ..
                
                ![Untitled](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/Untitled.png)
                
        - FAT 파일 시스템의 장단점
            - 장점
                - 단순하여 구현이 쉽고 외부 단편화가 없음
            - 단점
                - 파일당 1/2블록 크기로 내부 단편화 발생
                - 하나의 파일을 순차적으로 읽는 경우 한 블록씩 읽어야 하므로 디스크 헤드를 움직이는 탐색 시간이 큼
                - FAT 테이블 영역이 손상되면 파일 시스템 전체를 읽을 수 없음
        
        3.3 Unix 파일 시스템
        
        - 부트 블록 : 부팅이 진행될 때 처음에 메모리로 적재되는 디스크 블록 → 운영체제를 적재하는 코드와 부팅 시 필요한 정보가 저장됨
        - 수퍼 블록
            - 파일 시스템의 유지 관리를 위해 중요한 파일 시스템 메타 정보가 기록되는 공간
            - 메타 정보들 : 파일 시스템 크기와 상태정보(수퍼블록의 수정여부), 블록 크기, 자유 블록 수, 자유 i-node 수 등 ..
            - 수퍼 블록은 파일 생성,읽기 과정에서 커널에 의해 자주 액세스 → 부팅 초기 메모리에 적재
            - 파일 입출력 동안 수퍼블록은 계속 갱신 → 주기적으로 디스크의 수퍼 블록에 기록되어야 함
            - 손상의 위험 때문에 디스크에 백업 수퍼 블록을 만들어 놓음
        - i-node와 i-node 리스트
            - i-node (index node) : 파일 메타 정보가 기록되는 구조체, 파일마다 한개씩 사용, 대체로 64바이트나 128바이트 크기
            - i-node 리스트 : i-node들의 테이블, 수퍼 블록 다음에 저장, 개수 고정
            - 파일 생성될 때마다 빈 i-node 할당, 파일 메타 정보 기록
            - i-node 번호가 i-node 리스트 인덱스와 동일
            - i-node 번호는 0부터 시작, Unix는 1번부터 사용하고 Linux는 2번부터 사용
        - 데이터 블록들
            - 파일과 디렉터리가 저장되는 공간
            - 블록의 크기는 수퍼 블록에 기록, 대체로 4KB
        - 디렉터리
            - 디렉터리 항목은 파일이나 서브 디렉터리의 i-node 번호와 이름으로 구성됨
            - 초기 Unix는 16바이트
        
        ![스크린샷 2022-06-07 17.03.17.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_17.03.17.png)
        
        <aside>
        💡 Unix 파일 시스템의 Q&A
        
        Q1. Unix 파일 시스템을 사용할 때 만들 수 있는 파일 개수는 무엇에 달려있는가 ?
        
        A) 파일 하나당 하나의 i-node가 필요하므로 i-node리스트에 있는 i-node 개수에 달려있다.
        
        Q2. 수퍼 블록이 메모리에 적재된 채 사용되어야 하는 이유는 ?
        
        A) 커널은 파일이 생성되고 삭제될때마다 수퍼블록을 읽고 쓰는 작업이 발생하기 때문에, 커널코드의 실행을 빨리 하기 위해 수퍼 블록을 메모리에 적재하고 사용한다.
        
        Q3. Unix 파일 시스템에서 파일 시스템 메타 정보와 파일 메타 정보는 어디에 저장되는가 ?
        
        A) 파일 시스템 메타 정보는 수퍼 블록에 기록되고, 파일 메타 정보는 i-node에 기록된다. 파일 이름은 디렉터리의 항목에 기록된다.
        
        </aside>
        
        - 파일 블록 배치, File Allocation
            - Unix 파일 시스템에서는 파일을 블록 단위로 디스크의 여러 블록에 분산 저장
            - i-node에 15개의 인덱스를 통해 파일이 저장된 디스크 블록들의 번호를 기억함
            
            `12개의 직접 인덱스 + 1개의 간접 인덱스 + 1개의 2중 간접 인덱스 + 1개의 3중 간접 인덱스`
            
            - 12개의 직접 인덱스, direct index
                - 12개의 파일 블록 번호, 디스크 블록 번호
                - 12개의 직접 인덱스로 가리킬 수 있는 파일 블록 수 = 12개 블록
                - 12개의 직접 인덱스로 가리킬 수 있는 파일 크기 = 12 * 4KB = 48KB
            - 1개의 간접 인덱스, single indirect index
                - 파일이 12개의 블록을 넘어갈 때 사용
                - 이 인덱스가 가리키는 한 개의 디스크 블록에 파일 블록 번호들이 들어 있음
                - 간접 인덱스로 가리킬 수 있는 파일 블록 수 = 1024개 블록
                - 간접 인덱스로 가리킬 수 있는 파일 크기 = 1024 * 4KB = 4MB
                - 인덱스로 사용되는 디스크 블록 수 = 1개
            - 1개의 2중 간접 인덱스, double indirect index
                - 2중 간접 인덱스로 가리킬 수 있는 파일 블록 수 = 1024 * 1024개 블록
                - 2중 간접 인덱스로 가리킬 수 있는 파일 크기 = 1024 * 1024 * 4KB = 4GB
                - 인덱스로 사용되는 디스크 블록 수 = 1 + 1024 = 1025개
            - 1개의 3중 간접 인덱스, triple indirect index
                - 3중 간접 인덱스로 가리킬 수 있는 파일 블록 수 = 1024 * 1024 * 1024개 블록
                - 3중 간접 인덱스로 가리킬 수 있는 파일 크기 = 1024 * 1024 * 1024 *4KB = 4TB
                - 인덱스로 사용되는 디스크 블록 수 = 1 + 1024 + (1024 * 1024)개
            
            `블록 번호가 32비트고 한 블록의 크기가 4KB일 때 Unix 파일 시스템에서 파일의 최대 크기는 48KB + 4MB + 4GB + 4TB` 
            
            ![i-node 속에 15개의 인덱스를 이용한 파일 블록 할당](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_17.18.59.png)
            
            i-node 속에 15개의 인덱스를 이용한 파일 블록 할당
            
            - 파일의 i-node를 찾는 과정
                
                ![/usr/source/main.c 파일의 i-node 번호와 블록 번호 알아내기](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_17.20.17.png)
                
                /usr/source/main.c 파일의 i-node 번호와 블록 번호 알아내기
                
                1_ 루트 디렉터리의 i-node 번호 알아내기
                
                2_ 루트 디렉터리의 i-node 읽기
                
                3_ 루트 디렉터리에서 /usr의 i-node 알아내기
                
                4_ /usr 디렉터리 읽고 /usr/source 파일의 i-node 번호 알아내기 
                
                5_ /usr/source 디렉터리 읽고 /usr/source/main.c 파일의 i-node 번호 알아내기
                
                6_ usr/source/main.c 파일 읽기
                
    4. 파일 입출력 연산
        - 파일 입출력은 커널에 의해서만 이루어지므로 응용프로그램에게는 관련 시스템 호출 함수가 제공됨
            
            `open(), read(), write(), close(), chmod(), create(), mount(), unmount() ..`
            
        
        4.1 파일 찾기
        
        - 파일의 경로명으로부터 파일의 i-node를 찾는 과정
        - 커널에 의해 이루어짐
        - i-node에 파일 데이터가 담겨있는 블록 번호, 파일 타입, 접근 권한 등이 들어있으니까 !
        
        4.2 파일 열기, open()
        
        - 파일을 왜 열까 ?
            - 파일이 존재하는지 확인
            - 현재 프로세스가 파일에 접근해도 되는지 접근 권한 확인
            - 파일을 읽고 쓰기 위한 커널 내에 자료구조 형성
        - 파일 존재 확인 → 존재하면 디스크에서 메모리로 i-node 읽어들이고 → 접근 권한 확인 → 파일을 읽고 쓰기 위한 커널 자료구조 형성
        - 파일 입출력을 위한 커널 내 자료구조들
            - 메모리 i-node 테이블
                - 열린 파일의 디스크 i-node를 읽어 메모리 내에 저장한 테이블
                - 시스템에 1개 존재 → why? i-node는 계속 액세스 되니까 디스크 I/O 시간 줄이려고
            - 오픈 파일 테이블
                - 시스템에서 열려있는 모든 파일에 관한 정보를 기록하는 테이블
                - 시스템에 1개 존재
                - 이 항목에는 파일 R/W모드, 파일 옵셋, 메모리 i-node의 메모리 주소 등으로 구성
                - 파일이 열릴 때마다 오픈 파일 테이블의 새 항목이 사용됨, 모든 프로세스에 의해 공유됨
                - 오늘날에는 오픈 파일 테이블을 동적으로 할당하고 이중 연결 리스트로 구성한다. 개수 고정 X
            - 프로세스별 오픈 파일 테이블
                - 프로세스당 1개 존재
                - 프로세스가 파일을 열 때마다 테이블에 1개의 항목이 사용됨
                - 이 항목에는 오픈 파일 테이블에 대한 메모리 주소가 기록됨
                - “프로세스가 열어놓은 모든 파일에 대해 오픈 파일 테이블에 대한 주소가 기록된 배열”
                - 운영체제마다 다르지만 Unix 계열의 경우 PCB(Process Control Block)에 저장됨
            - 버퍼 캐시
                - 커널 공간에 만들어지고 파일을 읽고 쓰는 과정에서 파일 블록들을 일시적으로 저장하는 메모리 공간
                - 여기에 저장되는 블록들은 오직 디스크 블록 번호로만 관리
                - 여기에 쓰여진 블록들은 추후 커널에 의해 적절한 시점에 디스크에 기록됨
        - 파일 열기 과정
            
            ![파일 열기 후 형성되는 커널 자료 구조](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_17.27.24.png)
            
            파일 열기 후 형성되는 커널 자료 구조
            
            1_ 파일 이름으로 i-node 번호 알아냄 
            
            2_ 디스크 i-node를 메모리 i-node 테이블에 적재
            
            3_ 오픈 파일 테이블에 새 항목을 만듦 
            
            4_ 프로세스별 오픈 파일 테이블에 새 항목을 만듦 
            
            5_ open()은 프로세스별 오픈 파일 테이블의 항목 번호를 리턴
            
        - 파일 디스크립터, file descriptor
            - 열린 파일마다 매겨진 고유한 정수 번호
            - 파일을 연 응용프로그램에게 전달, open()의 리턴 값
            - 0과 양의 정수만 사용
            - 프로세스별 오픈 파일 테이블의 인덱스로서 응용프로그램이 열어 놓은 파일을 대변하는 값
            - 응용프로그램은 파일 입출력 시 이 정수를 반드시 사용
            - 파일 디스크립터, 프로세스별 오픈 파일 테이블의 인덱스의 0,1,2 항목
                - 0 : 표준 입력 장치
                - 1 : 표준 출력 장치
                - 2 : 표준 오류 장치
        
        <aside>
        💡 # 열 수 있는 파일 개수에는 제한이 있을까 ?
        
        → 파일을 열 때마다 커널 메모리가 소모되므로 대부분의 운영체제는 파일을 무제한 열도록 허용하지 않는다. 보안 때문이기도 하다.
        
        </aside>
        
        4.3 파일 읽기, read()
        
        ![스크린샷 2022-06-07 17.50.29.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_17.50.29.png)
        
        1_ read(fd, ..)는 fd 번호의 프로세스별 오픈 파일 테이블 참조
        
        2_ 파일 테이블 참조, R 모드가 아닌경우 오류 리턴
        
        3_ i-node 참조 (i-node에서 파일 블록들의 리스트 확보, offset 확인, offset을 파일 블록 번호로 변환)
        
        4_ 해당 블록이 버퍼 캐시에 있는지 확인
        
        5_ 버퍼 캐시로부터 사용자 영역으로 블록 복사
        
        4.4 파일 쓰기, write()
        
        ![스크린샷 2022-06-07 17.59.30.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_17.59.30.png)
        
        1_ write(fd, ..)는 fd 번호의 프로세스별 파일 테이블 참조
        
        2_ 파일 테이블 참조, W 모드 아니면 오류
        
        3_ i-node 참조 (i-node에서 파일 블록들의 리스트 확보, 파일 테이블 항목의 offset 확인, offset을 파일 블록 번호로 변환)
        
        4_ 해당 블록이 버퍼 캐시에 있는 지 확인
        
        5_ 사용자 공간의 버퍼에서 버퍼 캐시로 쓰기
        
        6_ 추후 버퍼 캐시가 교체되거나 플러시 될 때, 버퍼 캐시의 내용이 저장 장치에 기록
        
        4.5 파일 닫기, close()
        
        ![스크린샷 2022-06-07 18.01.49.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-07_18.01.49.png)
        
        1_ 프로세스의 오픈 파일 테이블 항목에 기록된 내용 지우기
        
        2_ 프로세스의 오픈 파일 테이블 항목을 지우기 전, 파일 테이블의 항목을 찾고 지우고 반환
        
        3_ 파일 테이블 항목을 반환하기 전, 메모리 i-node의 사용 해제
        
        4_ 버퍼 캐시에 있는 이 파일의 블록들이 수정되었거나 새로 만든 블록일 경우 디스크에 기록
        
- chap12 : 대용량 저장 장치 관리
    1. 저장 장치 개요
        
        1.1 저장 장치의 특징
        
        - 목적 : 프로그램이나 데이터를 보조적으로 저장
        - 특징
            - 대용량 (주기억장치보다 최소 1000배 이상 대용량)
            - 비휘발성 영구 기억 (전원이 꺼져도 저장된 데이터가 지워지지 않음)
            - 가상 메모리의 스왑 공간으로 활용, 데이터베이스나 파일 저장
            - 수명이 컴퓨터 교체 시기보다 길어 거의 영구적이라고 할 수 있음
        
        1.2 저장 장치의 성능 및 신뢰성
        
        - 저장 장치의 입출력 병목 (I/O bottleneck) 문제 → 시스템 성능에 영향
            - 저장 장치가 입출력에 과부하가 걸려 있는 상태
            - 입출력 병목 현상 → CPU 유휴 시간이 늘어나고 시스템 전체가 느려짐
            - 해결 방법
                - 주기억장치 메모리 늘리기
                - 디스크 캐시 늘리기
                - 디스크 스케줄링
                - SSD와 같은 빠른 저장 장치, RAID 같은 병렬 저장 장치 사용
        - 저장 장치의 데이터 신뢰성 (data reliability) 문제 → 시스템 신뢰성에 영향
            - 저장 장치의 고장은 데이터의 손실 초래 → 심각한 문제
            - 해결 방법
                - 디스크 미러링
                    - 2개의 디스크에 항상 동일한 데이터가 기록 되도록 구현하고 사용자에게는 1개의 디스크처럼 보이게 하는 기법
                    - RAID 기법 중 하나로 RAID 레벨 1 이라고 부름
                    - 디스크 미러링 제어기는 호스트로부터 쓰기 명령 받으면 디스크 0, 1에 동일하게 기록하여 두 디스크가 항상 같은 내용을 가지게 함
                    - 핫 스와핑 : 시스템 동작 중 디스크 1이 고장나면, 고장난 디스크 1 제거 → 새 디스크에 자동으로 디스크 0의 데이터를 디스크 1에 복사해 복구시킴
                        
                        ![스크린샷 2022-06-13 18.03.49.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_18.03.49.png)
                        
                - RAID 기술
                    - 여러 개의 디스크에 패러티 정보와 함께 데이터를 분산 기록하여 디스크가 손상될 때 자동 복구하는 기술
                    - RAID 제어기는 블록들을 3개의 디스크에 돌아가면서 배치하고 한개의 디스크에는 패리티 블록을 만들어 저장
                    
                    ![스크린샷 2022-06-13 18.06.20.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_18.06.20.png)
                    
    
    1. 하드 디스크 장치
        
        2.1 하드 디스크 장치의 구조
        
        - 디스크 제어 모듈
            - 호스트로부터 명령을 받아 디스크 매체 모듈에게 지시하여 디스크 캐시와 디스크 매체 사이에 입출력이 이루어지도록 하고, 입출력 버스 인터페이스를 통해 디스크 캐시에 저장된 데이터를 호스트로 전송하거나 호스트로부터 디스크 캐시로 데이터를 수신한다.
            
            ![스크린샷 2022-06-13 18.08.36.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_18.08.36.png)
            
            - 입출력 버스 인터페이스
                - 입출력 버스를 통해 호스트로부터 입출력 명령을 수신하고 데이터를 주고받는 하드웨어
            - 프로세서
                - 운영체제로부터 전달받은 디스크 입출력 명령을 해석하여, 모터/코일 등 전기 기계 장치를 구동시켜 하드디스크의 암을 움직이거나 디스크 헤드를 제어해 플래터에서 읽고 씀
            - 디스크 캐시
                - 입출력되는 데이터의 임시 저장소 역할을 하는 빠른 반도체 메모리, 몇 십 MB 크기
                - 예측 읽기 (prefetch)를 이용해 호스트가 다음에 읽을 것으로 예측되는 데이터를 디스크 캐시에 읽어놓아 호스트의 응답 시간을 줄이기도 한다.
        - 디스크 매체 모듈
            - 플래터 : 완전한 원형 판의 자성체, 디지털 정보가 기록되는 곳
            - 디스크 헤드 : 플래터 위를 움직이면서 디지털 정보를 읽고 쓰는 장치
            - 암 : 디스크 헤드를 원하는 위치로 움직이는 장치
        
        2.2 입출력 버스
        
        - 하드 디스크와 호스트가 연결
        - ATA, SATA (Serial ATA), SCSI, IEEE 1394, Fiber Channel, USB
        
        2.3 디스크 저장 구조
        
        - 트랙, 섹터, 실린더
            - 플래터의 표면에는 여러개의 동심원을 따라 정보 저장 → 이 동심원이 트랙
            - 같은 동심원을 가진 트랙들을 모아 → 실린더
            - 플래터가 4장 있으면 실린더는 8개의 트랙으로 구성됨
            - 섹터 : 디스크 장치가 저장하고 읽는 최소 단위, 전통적으로 512바이트이지만 최근에는 4KB 크기의 고급 포맷을 사용하는 디스크가 주를 이룸
            - 하드디스크의 모든 플래터들은 하나의 스핀들에 연결되어 동시에 회전, 등각속도로 회전
        - 존 비트 레코딩
            - 전통적인 디스크는 등각속도 회전에 맞추어 안쪽, 바깥쪽 트랙마다 같은 개수의 섹터를 배치 → 안쪽 트랙에 비해 바깥쪽 트랙의 길이가 길어 바깥쪽 트랙일수록 저장되는 밀도가 낮음
            - 밀도가 낮은 바깥쪽 트랙에 더 많은 섹터를 배치하는 기법
            
            ![스크린샷 2022-06-13 18.24.28.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_18.24.28.png)
            
        - 디스크 물리 주소
            
            <aside>
            💡 CHS 물리주소 = [실린더 번호, 헤드 번호, 섹터 번호]
            
            </aside>
            
            - CHS 물리주소는 디스크의 목표 섹터를 나타내는 주소
            - 운영체제는 디스크의 모든 섹터를 일차원으로 펼치고 여러 섹터를 블록으로 묶어 논리 블록 주소를 사용하는데, 운영체제가 디스크 장치에게 논리블록 주소를 전달하면 디스크 장치는 이를 CHS 물리 주소로 변환하고 읽고 쓸 섹터를 결정 → 운영체제 커널은 디스크 장치의 하드웨어 스펙에 무관하게 작성할 수 있다!
        - 하드 디스크의 모터는 반시계 방향으로 회전
        
        2.4 디스크 용량
        
        <aside>
        💡 디스크 용량 = 실린더 개수 * 실린더당 트랙 수 * 트랙 당 섹터 수 * 섹터 크기
        
        </aside>
        
        - 실린더당 트랙 수 = 디스크 헤드의 개수
        
        <aside>
        💡 용량 계산 사례
        
        - 실린더 4000개
        - 실린더 당 트랙 수 2개
        - 트랙 당 섹터 수 2000개
        - 섹터 크기 512바이트
        
        (1) 디스크 총 트랙 개수는 ? 
        
        → 실린더 개수 * 실린더 당 트랙 수 = 4000 * 2 = 8000개
        
        (2) 트랙 당 저장 용량은 ?
        
        → 트랙 당 섹터 수 * 섹터 크기 = 2000 * 512바이트 = 약 1MB
        
        (3) 디스크의 총 저장 용량은 ?
        
        → 총 트랙 수 * 트랙 당 저장 용량 = 8000 * 1MB = 약 8GB
        
        </aside>
        
        2.5 디스크 입출력 과정 및 성능 파라미터
        
        - 디스크 장치가 운영체제로부터 받는 명령은 읽기/쓰기, 논리블록번호(LBA), 호스트의 메모리 주소, 읽거나 쓰는 블록 수 등으로 구성된다.
        - 입출력 과정 : 탐색, 회전 지연, 전송, 오버헤드
            
            ![스크린샷 2022-06-13 18.34.49.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_18.34.49.png)
            
        - 탐색 (seek)
            - 디스크 장치 내 모터를 이용해 디스크 헤드를 현재 실린더 → 목표 실린더로 이동시키는 과정
            - 탐색 거리 (seek distance) : 이동하는 실린더 개수
            - 탐색 시간은 전체적으로 탐색 거리에 선형적으로 비례
            - 상용 하드 디스크의 평균 탐색 시간은 5ms 내외 (ex. 전체 디스크 실린더 1000개라면, 평균 300개 정도 움직임. 3/1 → 5ms)
        - 회전 지연 (rotational latency)
            - 디스크 헤드가 탐색 후 플래터가 회전해 헤드 밑에 목표 섹터가 도달할때까지 기다리는 시간
            - 평균 회전 지연 시간 = 1/2 회전 시간
            - 디스크의 회전 속도는 분당 회전 수로 나타냄, 단위는 rpm (ex. 7200rpm → 1회전 시간= 60초/7200=8.33ms → 평균 회전 지연 시간=4.17ms)
            
            ![Untitled](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/Untitled%201.png)
            
        - 전송 (transfer)
            - 내부 전송 시간
                - 디스크 헤드가 플래터 표면에서 **디스크 캐시로** 데이터를 읽어오거나 반대로 디스크 캐시에서 플래터 표면에 데이터를 기록하는 시간
                - 디스크의 회전 속도와 관련
                
                <aside>
                💡 예시
                
                - 한 트랙이 1000개의 섹터로 구성됨
                - 섹터 크기는 512바이트
                - 한 트랙의 크기는 1000 * 0.5KB = 약 500KB
                - 디스크 회전 속도는 7200rpm
                - 1회전 시간은 8.3ms
                - 내부 전송 속도 = 8.3ms 동안 500KB을 읽어서 전송
                    
                    = 500KB/8.3ms = 60MB/초
                    
                - 디스크와 캐시 사이에 1초에 약 60MB가 전송됨
                </aside>
                
                - 디스크의 회전 속도가 빠를수록 내부 전송 속도가 빠르다
                - 디스크의 데이터 전송률은 이를 나타냄
            - 외부 전송 시간
                - 디스크 캐시와 호스트 컴퓨터 사이에 데이터가 전송되는 시간
                - 디스크 장치와 호스트 컴퓨터가 연결되는 I/O 버스의 속도에 달려 있음
        - 오버헤드 시간 (overhead)
            - 호스트로부터 명령을 받고 해석하는 시간
            - 요청 블록들이 동일한 실린더의 다른 트랙으로 연속되는 경우 한 디스크 헤드에서 액세스하는 기능이 다른 헤드로 변경되는 시간 (head switch time)
            - 몇 마이크로초 수준으로 매우 작음
        - 디스크 액세스 시간과 디스크 입출력 응답 시간
            - 디스크 액세스 시간
                - 목표 섹터에 접근하여 읽거나 쓰기까지 걸리는 전체 시간
                - 탐색시간 + 회전 지연 시간 + 내부 전송 시간
                - 전송 시간을 빼고 탐색, 회전 지연 시간 만으로도 정의하기도 함
            - 디스크 입출력 응답 시간
                - 호스트나 응용프로그램 입장에서 디스크 입출력에 걸리는 전체 시간
                - 탐색시간 + 회전 지연 시간 + 전체 전송 시간 + 오버헤드
                - 가변적임
                - 이를 디스크 액세스 시간이라고 부르기도 함
                
        
        ** 평균 디스크 액세스 시간과 평균 디스크 응답 시간 계산
        
        ![스크린샷 2022-06-13 19.45.02.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_19.45.02.png)
        
    2. 디스크 스케줄링 알고리즘
        
        3.1 디스크 큐와 디스크 스케줄링
        
        - 디스크 장치는 호스트에서 발생하는 여러 디스크 입출력 요청을 저장하기 위해 디스크 큐를 둠
            
            ![스크린샷 2022-06-13 19.46.51.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_19.46.51.png)
            
        
        3.2 디스크 스케줄링의 목표
        
        <aside>
        💡 디스크 스케줄링의 기본 목표는 디스크 암이 움직이는 평균 탐색 거리를 최소화하여 평균 디스크 탐색 시간과 평균 디스크 액세스 시간을 줄여 디스크 처리율을 극대화하는 데 있다.
        
        </aside>
        
        - 디스크 처리율이 극대화되면 당연히 디스크 입출력 요청의 응답 시간도 짧아짐
        - 디스크 스케줄링은 평균 디스크 액세스 시간 감소 + 요청들의 응답 시간 편차를 줄이는 것도 함께 고려
        
        3.3 디스크 스케줄링 알고리즘
        
        - 평가 기준 : 평균 탐색 거리
        - FCFS, First Come First Served
            - 디스크 큐에 도착한 순서대로 요청 처리
            - 구현이 쉽고 기아 X
            - 요청 실린더들의 위치 고려 X → 평균 탐색 거리가 김, 성능 나쁨
            
            ![스크린샷 2022-06-13 19.51.21.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_19.51.21.png)
            
        - SSTF, Shortest Seek Time First
            - 현재 디스크 헤드가 있는 실린더에서 방향에 관계없이 가장 가까운 요청 선택
            - 탐색 거리가 가장 짧은 것을 선택해 성능 매우 좋음
            - 디스크 헤드에서 멀리 있는 요청들은 밀려나 기아 발생 가능성
            - 디스크 중간 범위의 실린더에 요청이 많은 경우 양 끝쪽 실린더에 대한 요청들은 오래 기다림
            - 평균 디스크 액세스 시간은 매우 짧지만 응답 시간 편차는 큰 편
            
            ![스크린샷 2022-06-13 19.53.52.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_19.53.52.png)
            
        - SCAN (Elevator)
            - 한쪽 실린더 끝에서 다른 쪽 실린더로 방향을 정한 후 그 방향으로 있는 요청들을 처리하면서 이동
            - 디스크 큐에 더 이상 이동 방향의 요청이 없으면 실린더 끝까지 스스로 이동 후 방향 바꾸고 동일한 과정 반복
            - SSTF보다 입출력 요청이 균등하게 이루어짐, 공평함
            
            ![스크린샷 2022-06-13 19.56.13.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_19.56.13.png)
            
        - LOOK
            - 현재 이동 방향으로 더 이상의 요청이 없는 경우 실린더 끝까지 안가고 즉시 이동 방향 바꿈
            - 양 끝 실린더의 요청이 중간 위치 실린더의 요청보다 선택될 확률 낮음
            
            ![스크린샷 2022-06-13 19.57.34.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_19.57.34.png)
            
        - C-SCAN, Circular SCAN
            - 맨 바깥쪽 실린더에서 맨 안쪽 실린더로 한 방향으로만 이동하면서 요청을 처리
            - 맨 안쪽 실린더에 도달하면 바로 바깥쪽 끝 실린더로 헤드를 옮기고 다시 안쪽 실린더 방향으로 요청을 처리하면서 이동
            - 한쪽 방향으로만 이동 → 요청들이 실린더 위치에 관계없이 더 균등하게 서비스 됨
            
            ![스크린샷 2022-06-13 20.44.51.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_20.44.51.png)
            
        - C-LOOK
            - C-SCAN + LOOK
            - 바깥쪽 실린더의 요청에서 안쪽 실린더로 요청을 처리하면서 이동하다가 이동하는 방향으로 요청이 없는 경우 바로 바깥쪽 실린더에서 가장 가까운 요청으로 한 번에 이동
            - 한 방향으로만 이동
                
                ![스크린샷 2022-06-13 20.46.18.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_20.46.18.png)
                
        - 성능 비교
            
            ![스크린샷 2022-06-13 20.46.48.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_20.46.48.png)
            
        - 비교
            
            ![스크린샷 2022-06-13 20.47.08.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_20.47.08.png)
            
    3. 디스크 포맷
        - 저수준 포맷팅 (LLF, Low Level Formatting) : 하드 디스크의 플레터에 트랙과 섹터를 구분하는 정보를 기록해 디스크 헤드가 섹터와 트랙을 인식할 수 있게 하는 작업
        - 고수준 포맷팅 (HLF, High Level Formatting) : 운영체제가 사용할 파일 시스템을 구축하고 파티션 테이블과 컴퓨터가 부팅할 때 작동할 코드를 기록하는 과정, 우리가 하는 포맷은 이거임
        
        4.1 저수준 포맷팅
        
        - 1990년대를 기점으로 디스크 용량이 증가함에 따라 디스크들은 공장에서 저수준 포맷이 된 채로 출시됨
        - 섹터 크기에 따라 두 가지로 분류
        - 512바이트 섹터 포맷
            - GAP : 다음 섹터를 읽기 전 플래터가 회전하는 동안 디스크 헤드가 준비하는 약간의 시간을 벌기 위해 삽입된 공간
            - SYNCH 바이트 : 디스크 헤드가 GAP의 끝을 인식하도록 약속된 코드
            - Address Mark : 섹터의 물리적 주소가 새겨지는 공간, [트랙 번호, 헤드 번호, 섹터 번호]로 구성됨
            - ECC(Error Correction Code) : 읽거나 쓰는 과정에서 손상된 섹터 데이터의 복구나 교정을 위해 추가 기록되는 데이터, 일종의 parity bit 같은 거
        - 4K 포맷
            - 기존 8개 섹터를 하나의 섹터로 만든 것, 고급 포맷 이라고도 함
            - 목적
                - 디스크의 저장 효율을 높이기 위함
                - 512바이트 섹터 포맷에서는 512바이트마다 1개의 ECC를 두지만, 4K 포맷에서는 4KB당 하나만 두는 대신 50바이트의 ECC를 100바이트로 늘려 오류 수정 능력을 대폭 향상시킴
                - 디스크 입출력 성능을 향상시킴
            - 현대의 응용프로그램은 저장량이 매우 커서 4KB 단위의 입출력이 더 효율적
        
        4.2 고수준 포맷팅
        
        - 저수준 포맷된 하드디스크를 여러개의 파티션으로 나누고 각 파티션에 파일 시스템을 구축하는 과정
        - 고수준 포맷팅은 디스크 저장 공간을 파티션들로 분할하는 과정부터 시작
        - MBR 포맷
            - 구성
                - 부트 로더 : 446바이트, 부팅 시 실행되는 프로그램
                - 파티션 테이블 : 64바이트, 최대 4개의 파티션 정보 기록, 각 파티션 정보는 16바이트
                - 매직 번호 : 2바이트, 0xAA55 기록, 0xAA55가 아니면 MBR이 아니라고 판단
            - 파티션에 관한 정보는 부트 섹터에 기록, 이 부트 섹터가 MBR (Master Boot Record)
            - 크기는 512바이트
            - 파티션 테이블에는 최대 4개까지 파티션 정보가 기록됨
            - 부팅이 시작되면 MBR에 저장된 부트 로더 프로그램이 메모리에 적재되고 실행되어 파티션 테이블을 검사하여 현재 부팅할 운영체제를 담고 있는 활성 파티션을 찾고, 활성 파티션의 부트 섹터를 메모리에 적재시키고 부트 섹터의 코드를 실행한다.
            
            <aside>
            💡 MBR 포맷의 단점은 파티션의 크기가 2TB로 제한되며 부팅 속도가 느려진다는 거 ..
            
            </aside>
            
            ![스크린샷 2022-06-13 23.04.35.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_23.04.35.png)
            
        - GPT (GUID partition table) 포맷
            - UEFI(Unified Extensible Firmware Interface) 펌웨어를 가진 컴퓨터에서만 사용하는 포맷 방식
            - 2TB 이상의 파티션을 만들 수 없는 MBR의 문제를 개선
                
                ![스크린샷 2022-06-13 23.09.20.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-13_23.09.20.png)
                
            - 보호 MBR 섹터가 첫 번째 섹터에 있는 이유 : 사용자가 GPT 포맷 디스크에 MBR 포맷만 다루는 유틸리티를 실행시켰을 때, 이 유틸리티가 현재 디스크에 훼손이 일어났다고 오인해 디스크를 새로 포맷하거나 오작동하는 것을 막기 위해 → GPT 포맷 디스크를 MBR 포맷 디스크로 보이게 하려는 목적, 첫 파티션이 전체 디스크를 모두 사용하고 있다고 착각하게 만든다
            - GPT 포맷을 다루는 소프트웨어들에게는 현재 GPT 포맷임을 나타내기 위해 보호 MBR 섹터의 파티션 테이블에서 첫 번째 파티션 항목의 파티션 타입 필드 값을 0xEE로 기록
            - GPT 포맷 디스크에서 진짜 파티션 테이블은 GPT 헤더 다음에 구성됨. 총 128개까지 파티션 가능, 한 파티션의 크기는 18엑사바이트까지 가능
            - GPT 헤더와 파티션 테이블을 이중화, GPT 헤더와 파티션 테이블은 디스크 마지막 영역에 백업본 → 손상 시 복구 가능
            
            ⇒ 이러한 이유로 GPT 포맷이 MBR 포맷보다 디스크에 대한 신뢰도가 높다
            
        - MBR 포맷 디스크의 부팅
            
            (1) 전원이 켜지면 CPU는 BIOS 펌웨어 코드의 실행 시작 → 메모리나 기타 장치들 테스트, 초기화
            
            (2) BIOS 안의 부트스트랩 코드 실행
            
            (3) 부트스트랩 코드는 하드 디스크의 첫 번째 섹터 즉 MBR 섹터를 메모리로 읽어들이고 점프
            
            (4) CPU가 이 코드를 실행하면 활성 파티션을 찾고, 활성 파티션의 부트 섹터를 메모리로 읽어들이고 실행
            
            (5) 부트 섹터의 코드는 자신의 파티션에 설치된 운영체제 커널을 메모리로 적재
            
            (6) 커널로 제어를 넘김
            
        - GPT 포맷 디스크의 부팅
            
            (1) 전원이 켜지면 컴퓨터에 장착된 UEFI 펌웨어 실행
            
            (2) UEFI 펌웨어에 저장된 EFI 변수를 읽음
            
            (3) 기본 파티션 테이블에서 EFI 시스템 파티션을 찾음
            
            (4) UEFI 펌웨어는 EFI 변수에 지시된 부팅 순서에 따라 EFI 파티션에서 부트 로드 프로그램을 찾아 실행
            
            (5) 부트 로더 프로그램은 해당 운영체제를 메모리에 적재 후 운영체제 코드로 점프해 실행
            
        - Windows에서 파티션 나누고 사용
            - 용도
                - D:, E: 등의 논리 드라이브로 사용
                - 복구 파티션
                - 진단 도구나 진단 데이터를 저장하는 파티션
        - 리눅스에서 파티션 나누고 활용
            - 각 디스크 파티션에는 파일 시스템이 구축되거나 파티션이 통째로 스왑 영역으로 사용
            - 여러 파티션을 디렉터리에 연결하여 전체를 하나의 파일 시스템으로 사용
            - 마운트 : 파티션을 디렉터리에 연결하는 것
            - 마운트 포인트 : 다른 파티션을 연결하기 위해 사용되는 디렉터리
            - 마운트 포인터는 다른 파티션에 설치된 파일 시스템의 루트 디렉터리가 된다
            
            ![스크린샷 2022-06-14 05.24.10.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-14_05.24.10.png)
            
        
    4. SSD 저장 장치
        - SSD(Solid State Drive)는 플래시 메모리를 저장소로 사용한 비휘발성 기억 장치
        - 순수 반도체 기억 장치
        - 디스크보다 값이 비싸지만 입출력 속도가 5~50배 정도 빠름
        
        5.1 SSD 장치의 구조와 인터페이스
        
        - 플래시 메모리
            - SSD 내부의 저장소, SSD 제어기 칩 속에 들어 있는 플래시 제어기에 의해 읽혀지고 기록됨
        - DRAM 캐시
            - 많은 SSD들은 입출력 성능을 높이기 위해 DRAM 캐시를 둠 → 비용 비쌈
            - 디스크 캐시와 비슷한 목적으로 사용되어 읽은 데이터나 쓸 데이터를 임시 저장
        - 호스트 인터페이스 회로
            - SSD 장치와 호스트를 연결하는 물리적인 인터페이스
            - SATA, SAS, PCIe
        - SSD 제어기, SSD Controller
            - SSD 장치에서 가장 중요한 부분
            - SSD 제어기는 하나의 칩으로 만듦
        
        5.2 SSD 메모리의 논리 구조
        
        - 페이지와 블록
            - **SSD 장치 내에서 플래시 메모리에 읽고 쓰는 단위는 페이지이다.**
            - 블록이나 페이지의 위치에 따라 액세스하는 시간이 다르지 않다.
            
            ![스크린샷 2022-06-14 06.19.17.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-14_06.19.17.png)
            
        
        5.3 SSD의 플래시 변환 계층
        
        - HDD 기반의 운영체제 파일 시스템은 디스크를 섹터 단위로 인식, SSD는 페이지 단위로 인식
        - 섹터를 기반으로 하는 기존의 파일 시스템으로는 SSD를 읽고 쓸 수 없음 → 문제 해결을 위해 플래시 변환 계층 (FTL, Flash Translation Layer) 이라는 펌웨어를 둔다
            
            ![스크린샷 2022-06-14 06.25.12.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-14_06.25.12.png)
            
        - 플래시 변환 계층은 운영체제의 파일 시스템에게 SSD가 섹터 기반의 저장소로 보이게 함
        
        5.4 SSD 입출력 동작
        
        - 페이지 읽기 (read)
            - 플래시 메모리에서 페이지 읽기는 단순함
        - 페이지 쓰기 / 프로그램 (write / program)
            - 플래시 메모리에 쓰기를 프로그램이라고 부름
            - 동일한 페이지에 덮어쓰기는 불가능, 빈 페이지에만 쓰기가 가능
            - read-modify-write
                
                ![스크린샷 2022-06-14 06.29.00.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-14_06.29.00.png)
                
            - 쓰기가 이런 식으로 이루어지는 이유 **!
                - 플래시 메모리는 쓰기와 지우기 횟수에 제한 → 한 블록에 쓰기나 지우기가 집중 반복되면 블록의 수명이 빨리 다해 전체 SSD의 수명을 단축시키게 됨
                - 여러 페이지로 쓰기를 분산하기 위해
        - 블록 지우기 (erase)
            - 플래시 메모리는 블록 단위로 데이터를 지움
            - 운영체제는 읽기나 쓰기만 가능
            - 블록 지우기는 SSD 제어기가 가비지 컬렉션을 수행할 때 빈 블록을 확보하기 위해 내부에서 벌어지는 동작
        - 가비지 컬렉션 (garbage collection)
            - dirty 페이지가 많아지고 블록 내 빈 페이지가 없게 되면 SSD 제어기에 의해 가비지 컬렉션이 수행된다
                
                ![스크린샷 2022-06-14 06.32.53.png](OS%20STUDY_FINAL%202156a9d42f344e9aa52e85bdc514b2c4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-14_06.32.53.png)
                
        - 웨어 레벨링 (wear leveling, 균등 쓰기 분배)
            - 플래시 메모리 블록은 쓰기나 지우기 횟수에 비례하여 닳아 감
            - 웨어 레벨링은 플래시 메모리의 모든 블록에 쓰기를 균등하게 분배하여 특정 블록에 과도한 쓰기를 막아 플래시 메모리의 고장이나 데이터 손실을 예방하는 기법
        
        5.5 SSD의 용도
        
        - 읽기가 많은 운영체제 코드나 프로그램 설치 용도에 적합
        - NAND 플래시 : SSD의 핵심 부품으로 저장소 역할, 전원이 공급되지 않은 채 오랜 시간이 지나면 전하 누출로 저장된 데이터가 지워짐 → 백업 저장 목적에는 부적절
        - 쓰기나 수정 작업이 많은 스왑 영역이나 임시 파일 시스템에 부적합 → SSD의 수명이 일찍 다함