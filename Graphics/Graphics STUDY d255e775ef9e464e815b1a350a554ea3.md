# Graphics STUDY

강의 번호: Graphics

- chap01
- chap02 : Modeling, Lendering
    - 모델링과 렌더링
        - 모델링 : 만들고자 하는 물체를 자료구조로 생성하는 것
        - 렌더링 : 모델링된 데이터를 이용해 화면에 그림으로 나타내는 것
    - 래스터 장비가 계단현상을 유발하는 이유
        - 래스터 장치는 화소의 2차원 배열로 영상을 표현하므로, 선이나 면을 점들의 나열로 표현하기 때문
- chap03 : Color Model
    - 칼라 프린터 잉크는 yellow, magenta, cyan으로 되어있고, 검정색 잉크도 포함됨. 검정색 잉크가 포함되어 유리한 점
        - 비용이 절약됨
        - 올바른 명도
    - HSV 색상모델에서 (H : Hue) H 값이 작은 상태에서 커진다는 것은 ?
        - 무지개 스펙트럼을 따라 빨강,노랑,파란색 등으로 변경된다는 뜻
    - RGB 컬러모델 (** 암기)
        
        ![스크린샷 2022-04-17 오후 9.46.54.png](Graphics%20STUDY%20d255e775ef9e464e815b1a350a554ea3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.46.54.png)
        
    - CMY 컬러모델
        
        ![스크린샷 2022-04-17 오후 9.47.59.png](Graphics%20STUDY%20d255e775ef9e464e815b1a350a554ea3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.47.59.png)
        
    - RGB 모델의 단점 : 직관적 X (ex: 보라색은 R,G,B 각각 얼마?)
        
        → 그래서 나온게 HSV
        
    - HSV (Hue, Saturation, Brightness / 색상, 명도, 채도) 컬러모델
- chap04 : openGL API
    - GL 프로그램 구성요소
        - GL 라이브러리 : 렌더링 기능을 제공하는 함수 라이브러리, 순수 그래픽, 운영체제/하드웨어에 무관한 그래픽 명령어 집합
        - GLU : GL 라이브러리 도우미, 수학 함수들, GL 함수로 작성
        - GLUT : 사용자의 입력을 받아들이거나 화면 윈도우 제어, 윈도우 운영체제 기능과의 인터페이스
    - freeglut : .h .lb .dll 의 파일 구성으로 되어있음
        - .h : gl 함수가 있으니까 일단 컴파일 해줘 (오류시 컴파일 실패)
        - .lib : gl 함수의 본체, 기계어로 컴파일 되어있음 (오류 시 링크 에러), lib까지 잘 되어있으면 컴파일은 잘 됨
        - .dll : 실행 시 사용함수, 기계어로 되어있음 (오류 시 실행 에러)
    - openGL
        - gl은 명령어 X, 함수명
        - glColor3f (r,g,b) : 그림 그릴 때 색은 이걸로 그릴거야
        - glVertex3f(x,y,z) : x,y,z 좌표로 꼭짓점 지정해줘, 3차원 정점으로 지정할거야→3f
        - glBegin() / glEnd() : 나 그림 그릴거야 / 이제 그만 그릴거야
        - glFlush() : 프레임 버퍼에 들어있는 값을 그려줘
        - glClearColor(1.0, 1.0, 1.0, 1.0) : 화면을 지우게 된다면 이 색상으로 지워줘 (흰색)
- chap05 : openGL Basic Tool
    - 입력 모드
        - Measure : 응용 프로그램에게 전달되는 입력값
        - Trigger : 전달하라는 신호
        - ex) DIR <ENTER> (DIR:메저, <ENTER>:트리거)
        1. 리퀘스트 모드
            - 프로그램이 실행 중 메저를 요구, 트리거가 일어날 때까지 대기
            - 트리거가 입력될 때 까지 어떤 값이 입력되었는지 알 수 없음
            - 실시간으로 입력값을 받아야하는 프로그램에는 부적합
        2. 샘플 모드
            - 사용자 트리거 불필요
            - 이미 필요한 메저가 준비된 상태
            - 계속 함수호출을 해서 어떤 키가 입력되었는지 확인 → 효율 떨어짐
        3. 이벤트 모드 (openGL에서 사용)
            - 사용자가 입력/선택 주도권 있음
            - 이벤트 발생하면 정보와 키 값이 이벤트 레코드에 저장
                
                → 응용프로그램은 필요할 때 메모리에서 확인
                
    - 콜백 함수
        - 이벤트가 발생하면 이 함수를 호출해줘 → 이벤트를 바꿔끼면 다른 기능 가능
        - 미리 등록해놓으면 정해진 콜백함수를 실행하므로 내가 원하는 동작 실행
        - GL의 콜백 - idle콜백 : 큐에 이벤트가 없을 때 실행, 드라이버 통해 주기적으로 이벤트 검사
    - 뷰포트
        - 윈도우를 분할해 그리기가 뷰포트 내로 제한
        - glViewPort(x,y,w,h) → x,y 위치에서 w,h 크기로 그려줘
    - GLUT vs GL
        
        
        | GLUT | GL |
        | --- | --- |
        | text 기반 → y방향이 위에서 아래로 | 수학 기반 → y방향이 아래에서 위로 |
    - GLUT 함수들
        - glutInitDisplayMode(GLUT_RGB) : 출력하는 모드를 어떤 것으로 초기화 할 것이냐
        - glutInitWindowSize(500,500) : 창의 크기를 결정
        - glutInitWindowPosition(0,0) : 창이 모니터로부터 어디 위치에
        - glutReshapeFunc : 창의 크기가 변경되면 호출되는 콜백함수
        - glutKeyboardFunc : 키보드가 눌린 경우
            - void MyKeyboard (unsigned char KeyPressed, int x, int y)
                
                → 이 때 x, y는 키보드가 눌렸을 때의 마우스 좌표
                
        - glutSpecialFunc : 특수 키가 눌린 경우
            - void MySpecialFunc (int key, int x, int y)
        - glutMouseFunc : 마우스가 클릭된 경우
        - glutMotionFunc : 마우스가 드래그 되는 경우
        - glutPassiveMotionFunc : 마우스가 클릭되지 않은 상태로 움직이는 경우
        - glutPostRedisplay : 그림 다시 그려줘
    - GLUT 모델링
        - glutSolidCube(), glutWireCube() → 정육면체 큐브
        - glutSolidSphere(), glutWireSphere() → 거미줄
        - glutSolidTorus(), glutWireTorus() → 도너츠
        - glutSolidCone(), glutWireCone()
        - glutWireIcosahedron() → 반지름 1인 정20면체
        - glutWireTeapot()
    - GLUT와 GL을 이용해 사각형 그리기
        - GL의 경우, 수학 좌표이기 때문에 일반적으로 -1 ~ +1 사이의 값을 가짐
            
            → 근데 편하게 하기 위해 0 ~ +1 사이의 값으로 변환하기 위해 함수를 사용
            
                glOrtho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0) : (-1 ~ +1) 을 (0 ~ +1)로 바꿔줘
            
        - GLUT는 창의 크기가 300x300이라면, 0~300 사이의 값을 가짐
        - GLUT 좌표값을 GL로 변환해야되니까, (마우스 좌표는 GLUT로 들어오니까)
            
            300(창 크기)로 나눠주면 변환 완료!
            
            ex) 마우스 좌표는 (150,150) GLUT 값으로 들어오면 → 300으로 다 나눠서 GL좌표로 바꿔줌
            
            y좌표를 300에서 빼주는 이유는 GL과 GLUT y축 방향이 다르기 때문!
            
            ```cpp
            glVertex3f(TopLeftX / 300.0, (300 - TopLeftY) / 300.0, 0.0);
            glVertex3f(TopLeftX / 300.0, (300 - BottomRightY) / 300.0, 0.0);
            glVertex3f(BottomRightX / 300.0, (300 - BottomRightY) / 300.0, 0.0);
            glVertex3f(BottomRightX / 300.0, (300 - TopLeftY) / 300.0, 0.0);
            ```
            
        - 사각형 그린 걸 계속 누적해서 보여주고 싶다면, glClear(..) 함수를 MyDisplay() 함수 말고, 밑에 main 안의 gl 함수들이 모여있는 곳으로 옮겨주면 됨.
            
            → 사각형이 그려질때마다 MyDisplay함수가 계속 호출되는데, glClear는 화면을 지우기 때문에 한번만 실행되야 하므로 MyDisplay함수 내에서 제외시켜주면 됨!
            
    - 프레임 버퍼
        - 2중 포트 구조, Read Port/Write Port
        - 버퍼를 읽어서 화면에 그리는 건 매우 빠르지만, 버퍼를 읽는 건 상대적으로 느림 (많은 데이터의 좌표 연산을 해야하니까)
        - 그래픽 프로세서 -1→ 프레임버퍼 -2→ 비디오 컨트롤러 → 디스플레이
        - 1 : 복잡한 데이터를 프레임 버퍼에 저장, 속도가 느림 / 0.1초
        - 2 : 읽기만 하면 됨, 속도 빠름 / 0.01초
        - 이렇게 시간 차이가 나버리면 애니메이션에서 문제, 그리다 만게 출력되면서 잔상이 남음
    - 더블 버퍼링
        - 프론트 버퍼와 백 버퍼, 총 두개 사용
        - 그래픽 프로세서 → 프론트/백 버퍼 → 비디오 컨트롤러 → 디스플레이
        - 그래픽 프로세서가 그리는 중 = 백 버퍼 → 여기서 다 그리면 백 버퍼가 프론트 버퍼로 바뀜
        - 그래픽 프로세서가 화면에 출력하는 중 = 프론트 버퍼
- chap06 : Model, Vector
    - 3차원 물체표현
        - 삼각형 메시 : 평면을 보장, 다각형 수는 2배, 삼각대 생각하면 됨
            
            → 무조건 점 세개 이으면 평면 하나가 만들어짐
            
        - 어파인 공간 : 점과 벡터를 동족으로 취급, 벡터공간 확장
            - 어파인 연산
                - 벡터 +(-) 벡터 = 벡터
                - 스칼라 *(/) 벡터 = 벡터
                - 점 +(-) 벡터 = 점
            - 어파인 공간에서 어파인 합
                - a점 + b점 = c점
                - a+b=1, 즉 점 계수의 합이 1인 경우 점+점=점 가능!
        - 동차좌표
            - 동차좌표 (1,2,2,1) = (2,4,2,2) = (3,6,3,3) ...
            - (x,y,z,w) = (x/w, y/w, z/w)
        - 기하변환
            - 행렬로 표현
            - 2차원 이동
                - (x,y)를 (3,2)만큼 이동 → 단위 행렬의 Tx=3, Ty=2로 하면 이동됨
            - 2차원 회전
                - 각도 R
                    
                    cosR -sinR 0
                    
                    sinR   cosR 0
                    
                    0         0      1
                    
            - 크기 조절
                - P’ = S(Sx,Sy,Sz) * P(x,y,z) → Sx,Sy,Sz만큼 크기 조절
                    
                    Sx   0    0    0
                    
                    0    Sy   0    0
                    
                    0     0   Sz   0
                    
        - **복합 변환 ****
            - 크기조절(S1) 후, 물체회전(R1) 후, 다시 크기조절(S2)
                - P’ = S2 * R1 * S1 * P
                    
                    → 점 P 기준으로 오른쪽에서 왼쪽으로, 순서 중요!!
                    
                - 결합법칙 성립, P’ = (S2 * R1 * S1) * P
                - P점이 3차원이라고 가정하고 곱셈 횟수를 따져봤을 때 첫번째는 48번, 두번째는 144번
                    
                    → 하지만 openGL은 두번째 방법을 선택한다.
                    
                    → 왜? 재활용성이 높기 때문에 P점이 10000개면 앞의 계산횟수를 미리 계산해놓고 100번 곱하면 되니까 오히려 곱셈횟수가 줄어듦
                    
            - 원점 기준 회전 VS 중심점(피봇) 기준 회전
                - 피봇 기준 회전
                    1. 피봇이 좌표계 원점에 일치하도록 물체 이동
                    2. 물체를 원점 기준으로 축 주위로 회전
                    3. 회전된 물체를 1번의 방향과 반대로 이동
                    - C = T(Xp, Yp, Zp) * Rz(seta) * T(-Xp, -Yp, -Zp) * P
                        
                        코드는 → 이 방향으로 써지고
                        
                        실제로 실행은 점 기준으로 하기 때문에 ← 이 방향으로 실행됨
                        
            - 이동 후 회전 / 회전 후 이동 : 교환법칙 성립X
            - 반사 : x,y 좌표값을 반대로 반사시킴
                - ex) (1,3) → (-1, -3)
                    - 단위행렬에서 1을 -1로 바꿔서 x,y에 곱해주면 완료
                        
                        -1   0   0
                        
                         0  -1   0
                        
                         0   0   0
                        
                - y=x 기준 반사 ex) (1,3) → (3,1)
                    - 복합변환으로 하면 회전하는 공식에다가 각도 -45’ 넣어주면됨
                    - 굳이? 그냥 좌표 서로 교환해주면 됨
        - 그래픽 변환
            - 강체 변환 : 이동, 회전 → 물체 자체 모습은 불변
            - 유사 변환 : 강체 변환 + 균등 크기조절 변환, 반사변환
                - 물체면 사이의 각 유지, 물체 내부 정점간의 거리가 일정한 비율로 유지
            - 어파인 변환 : 유사변환 + 차등(x,y,z 비율이 다른) 크기조절 변환
                - 물체의 타입 유지 (직선은 직선으로, 다각형은 다각형으로), 평행선 보존
                - 변환행렬의 마지막 행이 항상 (0,0,0,1) : 변환하려고 마지막에 1 삽입하니까
            - 원근 변환
                - 두 평행선이 변환 후 교차할 수 있음
                - 직선은 변환 후 직선으로 유지
                - 변환행렬의 마지막 행이 항상 (0,0,0,1) 아님
            - 선형 변환 : 어파인 변환 + 원근 변환
                - x’ = ax + by + cz 에서 x’은 x,y,z 변수에 각각 상수 배 한것을 더한 것
    - 모델 좌표계 (지역 좌표계)
        - 모델링 : 물체를 설계 = 물체의 정점을 정의
        - 좌표계 단위
        - 좌표계 원점 및 축방향 : 설계하는 사람 마음, 물체마다 다름
    - 전역 좌표계
        - 여러 물체가 존재 = 여러 지역 좌표계 존재
        - ⇒ 일률적으로 어우를 수 있는 전체 하나의 기준 좌표계
        - 임의 위치에 선정
    - 시점 좌표계
        - 바라보는 위치에 따라 장면 달라보임
    - 변환 행렬의 의미
        - 이동변환
            - 일반적 관점 : 변환행렬 T는 전역좌표계 기준으로 물체의 정점을 (x,y,z)만큼 이동 → 점이 움직였다
            - GL의 관점
                - 변환과 동시에 WCS와 MCS가 분리됨, 변환 후에도 MCS 기준 정점 좌표 불변
                - 좌표계가 이동했다
                - 전역좌표계를 (x,y,z) 만큼 이동하면 모델 좌표계랑 일치
                - “전역 좌표계를 모델 좌표계로 일치시키기 위한 것이 변환행렬이다”
    - GL의 모델 변환
        - glMatrixMode(GL_MODELVIEW) : 조작하고싶은 행렬 선택, Model행렬 조작할거야
        - glLoadIdentity() : 단위행렬로 초기화, 안하면 쓰레기 값
        - glScalef(sx,sy,sz) : 크기조절
        - glRotatef(seta,vx,vy,vz) : seta 각도로 회전
        - glTranslatef(x,y,z) : 평행이동
        - glBegin(), glVertex3f(x,y,z), glEnd()
            
            → 이 순서로 코드가 짜여있다면, 점 기준으로 실행되므로 **평행이동 → 회전 → 크기조절 순서로 실행 !!!**
            
            → 좌표계 변환 (GL 함수호출)은 위에서 아래로, 물체 변환은 아래에서 위로
            
    - 행렬
        - m개의 행(위→아래) n개의 열(왼쪽→오른쪽)을 가진 행렬 = n행 m열의 크기를 가진 행렬
        - 행렬 클래스
            
            ```cpp
            class mat3 {
            	float m[3][3]
            	mat3() {
            		for(int i=0; i<3; i++) {
            			for(int j=0; j<3; j++) {
            				m[i][j] = 0;
            			}
            		}
            	}
            }; 
            ```
            
        - 행렬의 곱셈
            
            ```cpp
            mat3 operator*(mat3 a) {
            	mat3 result;
            		for(int i=0; i<3; i++) {
            			for(int j=0; j<3; j++) {
            				for(int k=0; k<3; k++) {
            					result.m[i][j] += m[i][k] * a.m[k][j]
            			}
            		}
            	}
            return result;
            }; 
            ```
            
        - 단위 행렬
            - LoadIdentity() : for i,j 중첩으로 돌면서 i=j 인부분만 1, 나머지 0
            - 리턴할때 : 리턴타입→ mat3, return *this;
        - 전치 행렬
            - 행렬 M의 행, 열을 바꿔놓음
            - transpose() : for i,j 중첩으로 돌면서 [i][j] 를 [j][i]로
        - 역 행렬
            - 현재 행렬 M과 곱했을 때 단위행렬로 튀어나오는 행렬
                
                ![스크린샷 2022-04-18 오전 12.36.38.png](Graphics%20STUDY%20d255e775ef9e464e815b1a350a554ea3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_12.36.38.png)
                
    - 벡터
        - 행렬의 일종, 배열과 비슷
        - 벡터의 크기
            - (x,y,z) → 루트에 다 제곱해서 더하기
        - 내적 : 두 벡터의 시점을 일치시킨 뒤, 두 벡터가 이루는 각을 코사인값으로 나타낸 것
            - (x1,y1) * (x2,y2) = x1x2 + y1y2
            - a 내적 b = ||a|| ||b|| cos(theta)
            - 내적 함수 코드
                - (원래벡터x * 새로운벡터x) + (원래벡터y * 새로운벡터y) + (원래벡터z * 새로운벡터z) 리턴
            - 내적 예제 : 점 P(x,y)가 주어졌을 때 범위에 들어오는지, 안들어오는지 리턴하는 함수 작성
                
                ```cpp
                #include <iostream>
                #include <cmath>
                // sqrt : 루트씌우는 함수
                // pow : 제곱근 구하는 함수
                bool isInside (float x, float y) {
                    float a = 2;
                    float b = 1;
                    float inside = (a*x) + (b*y); // 내적값
                    float a_length = sqrt(pow(a,2)+pow(b,2)); // a제곱+b제곱에 루트씌우는 식
                    float p_length = sqrt(pow(x,2)+pow(y,2));
                    
                    float theta = inside / (a_length * p_length);
                    
                    if(theta <= 1 && theta >= (sqrt(3)/2))
                        return true;
                    else return false;
                }
                
                int main() {
                    bool res = isInside(1,10);
                    printf("%d\n",res);
                    return 0;
                }
                ```
                
        - 외적 : 두 벡터에 수직인 벡터 구하기
            
                a b c 
            
            x) d e f
            
            ⇒ (bf-ce, cd-af, ae-bd) 
            
            - 외적 함수 코드
                - 외적벡터 c
                    - c0 = a1b2 - b2a1
                    - c1 = a2b0 - a0b2
                    - c2 = a0b1 = a1b0